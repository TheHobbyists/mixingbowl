'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _errors = require('../errors');

var _protobufjs = require('protobufjs');

var _protobufjs2 = _interopRequireDefault(_protobufjs);

var _varint = require('varint');

var _varint2 = _interopRequireDefault(_varint);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var builder = _protobufjs2.default.loadProtoFile(_path2.default.join(__dirname, 'tetris.proto'));
var Packets = builder.build('tetris');

var idMap = {
    Handshake: 0,
    HandshakeACK: 1,
    Report: 2,
    Error: 3,
    ProgressUpdate: 4
};

Object.keys(idMap).forEach(function (key) {
    var Packet = Packets[key];
    var id = idMap[key];

    Packet.id = id;

    Packet.prototype.encodeOriginal = Packet.prototype.encode;
    Packet.prototype.encode = function () {
        return Buffer.concat([new Buffer(_varint2.default.encode(id)), this.encodeOriginal().toBuffer()]);
    };

    /**
     * Attempts to decode the packet.
     * @param  {Buffer} buf
     * @return {[type]}     [description]
     */
    Packet.decodeOriginal = Packet.decode;
    Packet.decode = function (buf) {
        _varint2.default.decode(buf, 0);
        var offset = _varint2.default.decode.bytes;

        var decoded = void 0;
        try {
            decoded = Packet.decodeOriginal(buf.slice(offset));
        } catch (e) {
            throw new _errors.FatalCodingError(e);
        }

        return decoded;
    };
});

/**
 * Decodes a packet from a buffer.
 * @param  {Buffer} buf
 * @return {Packet}
 * @throws {CodingError}
 */
Object.defineProperty(Packets, 'decode', {
    value: function value(buf) {
        var id = _varint2.default.decode(buf);
        if (id === undefined) {
            throw new _errors.FatalCodingError('Incomplete protobuf packet.');
        }

        var keys = Object.keys(idMap);
        for (var i = 0; i < keys.length; i++) {
            var p = Packets[keys[i]];
            if (p.id === id) {
                return p.decode(buf);
            }
        }

        throw new _errors.UnknownPacketError(id, buf);
    }
});

exports.default = Packets;