'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _errors = require('./errors');

var _events = require('events');

var _util = require('./util');

var _socketMaker = require('./socketMaker');

var _socketMaker2 = _interopRequireDefault(_socketMaker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The Connector provides a high-level interface, implemented to interact
 * with Tetrisd on the frontend and robot.
 */
var Connector = function (_EventEmitter) {
    _inherits(Connector, _EventEmitter);

    /**
     * Creates a new Connector.
     * @param {Function} decode
     * @param {Function} encode
     * @param {Function} errorPacket
     * @param {String} remote remote address of the server.
     */
    function Connector(encode, decode, errorPacket, remote) {
        _classCallCheck(this, Connector);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Connector).call(this));

        _this.handlers = [];
        _this.remote = remote;
        _this.errorPacket = errorPacket;
        _this.encode = encode;
        _this.decode = decode;
        _this.open = true;
        return _this;
    }

    /**
     * Attaches a heartbeater to the connector.
     * @param {Heatbeats} heartbeats
     */


    _createClass(Connector, [{
        key: 'heartbeater',
        value: function heartbeater(heartbeats) {
            this.beats = heartbeats;
        }

        /**
         * Attempts to start a connection to the remote server.
         * @param {Function} [callback]
         * @param {Function} [generator]
         */

    }, {
        key: 'connect',
        value: function connect() {
            var _this2 = this;

            var callback = arguments.length <= 0 || arguments[0] === undefined ? _util.noop : arguments[0];
            var generator = arguments.length <= 1 || arguments[1] === undefined ? _socketMaker2.default : arguments[1];

            var socket = this.socket = generator(this.remote);

            if (this.beats) {
                this.beats.start(socket);
            }

            (0, _util.bubble)('error', socket, this, 'bubbleOpen');
            // Always bubble close
            (0, _util.bubble)('close', socket, this);

            socket.once('open', function () {
                _this2.emit('connect');
                callback();
            });

            socket.on('unexpected-response', function (req, res) {
                callback(new _errors.UnexpectedServerResponse('Unexpected server response ' + res.statusCode));
            });

            socket.on('message', function (data) {
                return _this2.doDecode(data);
            });
        }

        /**
         * Attempts to decode an incoming message.
         * @param  {String|Buffer} data
         */

    }, {
        key: 'doDecode',
        value: function doDecode(data) {
            this.emit('raw-message', data);

            var message = void 0;
            try {
                message = this.decode(data);
            } catch (e) {
                if (e instanceof _errors.UnknownPacketError) {
                    this.emit('unrecognized', e.data);
                } else {
                    this.emit('error', e);
                }

                return;
            }

            this.handleIncoming(message);
        }

        /**
         * Sets whether the Connector is open. This is if the Connector
         * is currently connected _or trying to connection_. It's independent
         * of the underlying socket connection.
         * @param {Boolean} state
         */

    }, {
        key: 'setOpen',
        value: function setOpen(state) {
            this.open = state;
        }

        /**
         * Gets the opened state of the socket.
         * @return {Boolea}
         */

    }, {
        key: 'getOpen',
        value: function getOpen() {
            return this.open;
        }

        /**
         * Bubbles an event if the connector is open.
         * @protected
         * @param {String} event
         * @param {...} args
         */

    }, {
        key: 'bubbleOpen',
        value: function bubbleOpen(event) {
            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
            }

            if (this.open) this.emit.apply(this, [event].concat(args));
        }

        /**
         * Handles an incoming message. This watches for replies from "called"
         * functions before dispatching an event. Using this method, calls
         * can be safely concurrent.
         *
         * This relies partly on the assumption that requests set first will be
         * answered first (FIFO), which is currently an attribute of the Tetrisd
         * server. If this ever is not the case, the protocol will be adjusted
         * so that packets can be numbered.
         *
         * @private
         */

    }, {
        key: 'handleIncoming',
        value: function handleIncoming(message) {
            for (var i = 0; i < this.handlers.length; i++) {
                if (this.handlers[i](message)) {
                    this.handlers.splice(i, 1);
                    return;
                }
            }

            this.emit('message', message);
        }

        /**
         * Sends the packet to the server, then waits for the expected reply
         * (or an error) in response.
         * @param  {Object} packet
         * @param  {Class} Expected
         * @param  {Function} callback
         */

    }, {
        key: 'call',
        value: function call(packet, Expected, callback) {
            var _this3 = this;

            this.handlers.push(function (message) {
                if (message instanceof Expected) {
                    callback(undefined, message);
                } else if (message instanceof _this3.errorPacket) {
                    callback(message);
                } else {
                    return false;
                }

                return true;
            });

            this.send(packet);
        }

        /**
         * Sends a packet to tetrisd.
         * @param  {Packet} packet
         * @return {Connector}
         */

    }, {
        key: 'send',
        value: function send(packet) {
            var encoded = void 0;
            try {
                encoded = this.encode(packet);
            } catch (e) {
                return this.emit('error', e);
            }

            this.emit('sending', encoded);
            this.socket.send(encoded);
            return this;
        }

        /**
         * Closes the client socket.
         */

    }, {
        key: 'close',
        value: function close() {
            if (this.socket) {
                this.socket.close();
                this.socket = undefined;
            }

            if (this.beats) {
                this.beats.close();
                this.beats = undefined;
            }
        }
    }]);

    return Connector;
}(_events.EventEmitter);

exports.default = Connector;