'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.noop = noop;
exports.bubble = bubble;
exports.find = find;
exports.findValue = findValue;
exports.strRepeat = strRepeat;
exports.isNumber = isNumber;
exports.addIf = addIf;
exports.averageIf = averageIf;
exports.indent = indent;
exports.assert = assert;

var _errors = require('./errors');

function noop() {}

/**
 * Bubbles a certain event up from the child EventEmitter to the parent.
 * @param  {String} event
 * @param  {EventEmitter} child
 * @param  {EventEmitter} parent
 * @param  {String} [emit="emit"]
 */
function bubble(event, child, parent) {
    var emit = arguments.length <= 3 || arguments[3] === undefined ? 'emit' : arguments[3];

    child.on(event, function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return parent[emit].apply(parent, [event].concat(args));
    });
}

/**
 * Finds an item from the list; like Array.prototype.find, but for people
 * without the babel polyfill.
 *
 * @param  {Array} array
 * @param  {Function} predicate
 * @return {*}
 */
function find(array, predicate) {
    for (var i = 0; i < array.length; i++) {
        if (predicate(array[i])) {
            return array[i];
        }
    }

    return undefined;
}

/**
 * Similar to .find, but looks for and returns values in an object.
 * The predicate will be invoked with `(key, value)`.
 *
 * @param  {Object} obj
 * @param  {Function} predicate
 * @return {*}
 */
function findValue(obj, predicate) {
    var key = Object.keys(obj).find(function (k) {
        return predicate(k, obj[k]);
    });
    return obj[key];
}

/**
 * Repeats a string n times.
 * @param  {String} str
 * @param  {Number} times
 * @return {String}
 */
function strRepeat(str, times) {
    var output = '';
    for (var i = 0; i < times; i++) {
        output += str;
    }

    return output;
}

/**
 * Returns true if `n` is a number.
 * @param  {*} n
 * @return {Boolean}
 */
function isNumber(n) {
    return typeof n === 'number';
}

/**
 * Adds the numeric arguments and returns their result. Non-numeric
 * arguments will be ignored.
 * @param {Number...} numbers
 * @return {Number}
 */
function addIf() {
    var sum = 0;

    for (var _len2 = arguments.length, numbers = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        numbers[_key2] = arguments[_key2];
    }

    for (var i = 0; i < numbers.length; i++) {
        if (isNumber(numbers[i])) sum += numbers[i];
    }

    return sum;
}

/**
 * Averages the numeric arguments and returns the result. Non-numeric
 * arguments will be ignored.
 * @param {Number...} args
 * @return {Number}
 */
function averageIf() {
    var sum = 0;
    var count = 0;

    for (var _len3 = arguments.length, numbers = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        numbers[_key3] = arguments[_key3];
    }

    for (var i = 0; i < numbers.length; i++) {
        if (isNumber(numbers[i])) {
            sum += numbers[i];
            count += 1;
        }
    }

    return sum / count;
}

/**
 * Indents the string n times.
 * @param  {String} str
 * @param  {Number} times
 * @param  {String} indenter
 * @return {String}
 */
function indent(str, times) {
    var indenter = arguments.length <= 2 || arguments[2] === undefined ? '    ' : arguments[2];

    var indentation = strRepeat(indenter, times);
    var feed = /\r?\n/.exec(str);
    if (feed === null) return indentation + str;

    var lines = str.split(feed[0]);
    for (var i = 0; i < lines.length; i++) {
        lines[i] = indentation + lines[i];
    }

    return lines.join(feed[0]);
}

/**
 * Asserts that the `condition` is true.
 * @param  {Boolean} condition
 * @param  {String} error
 * @throws {AssertionError} if false
 */
function assert(condition) {
    var error = arguments.length <= 1 || arguments[1] === undefined ? 'expected false to be true' : arguments[1];

    if (!condition) {
        throw new _errors.AssertionError(error);
    }
}